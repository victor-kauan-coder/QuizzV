enunciado;resposta;justificativa
"O escalonamento por prioridades pode levar ao problema de inanição (starvation), onde processos de baixa prioridade nunca são executados.";True;"Verdadeiro — Se houver um fluxo contínuo de processos de alta prioridade, os processos de baixa prioridade na fila de prontos podem ser perpetuamente ignorados pelo escalonador."
"O algoritmo de escalonamento 'Tempo Restante Mais Curto em Seguida' (SRTN) é um exemplo de escalonamento não-preemptivo.";False;"Falso — SRTN é a versão preemptiva do algoritmo 'Tarefa Mais Curta Primeiro' (SJF)."
"A principal meta de um escalonador em sistemas em lote é minimizar o tempo de resposta para o usuário.";False;"Falso — A meta principal em sistemas em lote é maximizar a vazão (throughput). Minimizar o tempo de resposta é a meta para sistemas interativos."
"O 'grau de multiprogramação' refere-se à quantidade de núcleos de CPU em um sistema.";False;"Falso — O grau de multiprogramação refere-se ao número de processos que são mantidos na memória principal (RAM) ao mesmo tempo."
"A Tabela de Processos (PCB) armazena apenas os registradores e o contador de programa de um processo.";False;"Falso — A Tabela de Processos armazena todo o contexto de um processo, incluindo estado, prioridade, ponteiros de memória, arquivos abertos, etc."
"Um processo orientado à CPU tende a ter longos surtos de computação intercalados com curtas esperas por E/S.";True;"Verdadeiro — Essa é a definição de um processo 'CPU-bound', que passa a maior parte do tempo realizando cálculos."
"O modelo de comunicação cliente-servidor só pode ser implementado em uma única máquina, sem o uso de rede.";False;"Falso — Embora possa ser usado em uma única máquina, o modelo é fundamental para a comunicação em rede."
"A principal função de uma controladora de dispositivo é executar o código dos aplicativos do usuário.";False;"Falso — A função de uma controladora é ser a interface de hardware para um dispositivo, traduzindo comandos do SO em sinais elétricos."
"Variáveis de condição são utilizadas para que uma thread possa esperar por uma condição específica sem precisar ficar em um laço de espera ocupada.";True;"Verdadeiro — Elas permitem que uma thread bloqueie (durma) de forma eficiente até que outra thread a sinalize de que a condição foi atendida."
"A chamada `pthread_yield` força o término imediato da thread que a invocou.";False;"Falso — A chamada `pthread_yield` cede voluntariamente a vez da CPU para que outra thread possa ser executada."
"O problema do 'Jantar dos Filósofos' é um exemplo clássico de um problema de impasse (`deadlock`).";True;"Verdadeiro — É o exemplo canônico para ilustrar a condição de espera circular que pode levar a um deadlock."
"A atomicidade das operações `UP` e `DOWN` em um semáforo é garantida pelo programador da aplicação, não pelo SO.";False;"Falso — A atomicidade dessas operações deve ser garantida pelo sistema operacional para que o semáforo funcione corretamente."
"O RCU garante que um leitor sempre acessará a versão mais atualizada de um dado.";False;"Falso — O RCU garante que o leitor acessará uma versão consistente ('snapshot') do dado, que pode estar ligeiramente desatualizada."
"O 'período de graça' no RCU é o tempo que um escritor deve esperar antes de começar a fazer a cópia da estrutura de dados.";False;"Falso — O período de graça ocorre *após* o escritor publicar a nova versão, para garantir que todos os leitores que usavam a versão antiga tenham terminado."
"Aumentar a quantidade de memória em um sistema sempre melhora a utilização da CPU, sem limites.";False;"Falso — A melhoria de desempenho ocorre até o ponto em que a CPU se torna o gargalo do sistema."
"O 'sistema supervisor' é um componente de software que gerencia threads em implementações no espaço do núcleo.";False;"Falso — O sistema supervisor faz parte das bibliotecas de threads que são implementadas no espaço do usuário."
"Uma thread pode ler ou até mesmo apagar a pilha de outra thread que pertence ao mesmo processo.";True;"Verdadeiro — Como as threads compartilham o mesmo espaço de endereçamento, não há proteção de memória entre elas."
"A chamada `pthread_join` é usada para criar uma nova thread.";False;"Falso — A chamada `pthread_join` faz com que uma thread espere pelo término de outra. `pthread_create` é usada para criar."
"Nos monitores, a exclusão mútua é garantida implicitamente pela estrutura da linguagem, tornando o código menos propenso a erros.";True;"Verdadeiro — Essa é a principal vantagem dos monitores sobre semáforos; a exclusão é gerenciada pelo compilador."
"A alternância estrita (explicit alternation) é uma solução eficiente e flexível para o problema da região crítica.";False;"Falso — Ela é funcional, mas ineficiente, pois força os processos a se revezarem estritamente, mesmo que um seja muito mais rápido que o outro."
"No problema do produtor-consumidor, um 'wakeup perdido' pode ocorrer se o consumidor for interrompido logo após verificar que o buffer está vazio, mas antes de dormir.";True;"Verdadeiro — Essa é a condição de corrida clássica que as primitivas 'sleep' e 'wakeup' sozinhas não resolvem, necessitando de semáforos."
"O uso da instrução TSL (Test-and-Set Lock) elimina a necessidade de um laço de repetição (espera ocupada).";False;"Falso — A instrução TSL é atômica, mas ela é tipicamente usada *dentro* de um laço de espera ocupada para testar a trava repetidamente."
"A principal vantagem de desabilitar interrupções para garantir exclusão mútua é que essa solução funciona perfeitamente em sistemas com múltiplos processadores.";False;"Falso — Desabilitar interrupções só afeta o núcleo da CPU que executou a instrução, não funcionando em sistemas multiprocessados."
"A herança de prioridade é uma técnica onde uma tarefa de baixa prioridade herda a prioridade de uma tarefa de média prioridade que a está bloqueando.";False;"Falso — A tarefa de baixa prioridade herda a prioridade da tarefa de *alta* prioridade que está esperando pelo recurso que ela detém."
"Um sistema de tempo real não-crítico (soft) pode tolerar o descumprimento ocasional de um prazo.";True;"Verdadeiro — O descumprimento de um prazo degrada a qualidade, mas não causa uma falha catastrófica no sistema."
"O algoritmo de escalonamento FCFS (Primeiro a Chegar, Primeiro a Ser Servido) pode causar o 'efeito comboio', onde processos curtos esperam por um longo.";True;"Verdadeiro — Um processo longo que chega primeiro pode bloquear a execução de vários processos curtos que chegam depois."
"O 'quantum' no escalonamento Round-Robin é o tempo total que um processo pode usar a CPU antes de terminar.";False;"Falso — O quantum é a fatia de tempo máxima que um processo pode usar a CPU antes de ser preemptado e devolvido para o final da fila de prontos."
"O objetivo de uma LibOS em um sistema Exokernel é fornecer acesso direto e desprotegido ao hardware.";False;"Falso — O Exokernel fornece acesso *protegido* ao hardware; a LibOS implementa as abstrações de alto nível (como arquivos) no espaço do usuário."
"Um unikernel combina a aplicação e as bibliotecas de SO necessárias em uma única imagem de máquina, visando máxima segurança e mínimo tamanho.";True;"Verdadeiro — Essa é a definição de um unikernel, que remove a separação entre o SO e a aplicação."
"O conceito de 'Política versus Mecanismo' sugere que o sistema operacional deve sempre impor tanto as ferramentas de gerenciamento quanto a forma como elas são usadas.";False;"Falso — Ele sugere que o SO deve fornecer os mecanismos (as ferramentas) e permitir que a política (como usar as ferramentas) seja definida pelo usuário ou aplicação."
"O principal objetivo do modelo micronúcleo é maximizar o desempenho movendo todos os serviços para o modo núcleo.";False;"Falso — O objetivo do micronúcleo é aumentar a modularidade e a confiabilidade, movendo serviços para o espaço do usuário, o que pode até diminuir o desempenho em comparação com um núcleo monolítico."
"No sistema de camadas THE, uma camada superior pode invocar serviços de qualquer camada inferior a ela.";False;"Falso — Cada camada só pode invocar serviços da camada imediatamente inferior, garantindo uma estrutura organizada e de depuração mais fácil."
"O modelo Cliente-Servidor é considerado uma variação do modelo micronúcleo.";True;"Verdadeiro — O modelo cliente-servidor estende o conceito do micronúcleo, onde processos servidores (no espaço do usuário) oferecem serviços a processos clientes através de comunicação por mensagens."
"A multiprogramação permite a execução verdadeiramente paralela de múltiplos processos em um único núcleo de processador.";False;"Falso — A multiprogramação cria uma ilusão de paralelismo (concorrência), alternando rapidamente a execução dos processos. O paralelismo real requer múltiplos núcleos de processador."
"Um processo no estado 'Bloqueado' está consumindo ciclos da CPU enquanto espera por um evento.";False;"Falso — Um processo bloqueado não consome CPU. Ele é removido da fila de prontos pelo escalonador até que o evento (ex: E/S) que ele espera seja concluído."
"A transição do estado 'Pronto' para 'Bloqueado' é uma transição de estado válida para um processo.";False;"Falso — Um processo só pode ser bloqueado se estiver em execução e solicitar uma operação que não pode ser completada imediatamente. A transição correta é de 'Execução' para 'Bloqueado'."
"A estrutura de dados que o SO usa para armazenar informações sobre os processos em execução é chamada de Vetor de Interrupção.";False;"Falso — A estrutura é o Bloco de Controle de Processo (PCB). O Vetor de Interrupção mapeia interrupções para suas respectivas rotinas de tratamento."
"A chamada de sistema fork() no UNIX é um exemplo de criação de processo por solicitação do usuário.";True;"Verdadeiro — fork() cria um processo filho, duplicando o processo pai. É a maneira fundamental de criar novos processos em sistemas tipo Unix."
"Threads que pertencem ao mesmo processo compartilham o mesmo espaço de endereçamento.";True;"Verdadeiro — Threads de um mesmo processo compartilham memória (código, dados, heap), mas possuem sua própria pilha de execução e seus próprios registradores."
"A alternância de contexto entre threads do mesmo processo é mais lenta do que a alternância entre processos diferentes.";False;"Falso — É muito mais rápida, pois não é necessário trocar o mapa de memória (tabelas de página), apenas os registradores e a pilha."
"Em uma implementação de threads em modo usuário, o bloqueio de uma thread por uma chamada de sistema de E/S bloqueia o processo inteiro.";True;"Verdadeiro — Para o sistema operacional, o processo com threads em modo usuário é uma única entidade. Se uma parte dele bloqueia, o todo bloqueia."
"A principal vantagem das threads em modo núcleo é a velocidade de criação e comutação entre elas.";False;"Falso — A principal vantagem é que uma chamada de sistema bloqueante de uma thread não bloqueia o processo inteiro. A comutação é, na verdade, mais lenta que em modo usuário."
"O sistema supervisor faz parte da implementação de threads em modo núcleo.";True;"Verdadeiro — O sistema supervisor (kernel) é quem gerencia diretamente as threads, tratando de sua criação, escalonamento e sincronização através de chamadas de sistema."
"Cada thread em um processo possui sua própria pilha de execução.";True;"Verdadeiro — A pilha armazena as chamadas de função, argumentos e variáveis locais de cada thread, permitindo que executem de forma independente."
"Exclusão mútua é uma consequência indesejada de uma condição de corrida.";False;"Falso — Exclusão mútua é a principal técnica para PREVENIR uma condição de corrida, garantindo que apenas uma thread acesse a região crítica por vez."
"A espera ociosa (busy waiting) é uma técnica eficiente para evitar a inversão de prioridade.";False;"Falso — A espera ociosa é extremamente ineficiente, pois desperdiça ciclos de CPU. Além disso, não resolve a inversão de prioridade."
"Um semáforo binário pode ser usado para implementar a exclusão mútua.";True;"Verdadeiro — Um semáforo binário, também conhecido como mutex, é inicializado com 1 e garante que apenas uma thread possa executar a operação 'down' e entrar na região crítica."
"O problema da prioridade invertida ocorre quando uma tarefa de baixa prioridade é obrigada a esperar por uma de alta prioridade.";False;"Falso — Ocorre o inverso: uma tarefa de ALTA prioridade é forçada a esperar por uma de BAIXA prioridade que detém um recurso necessário."
"No escalonamento por múltiplas filas, um processo pode ser movido entre filas para evitar inanição.";True;"Verdadeiro — Essa técnica, chamada de múltiplas filas com retroalimentação (feedback), permite que um processo que espera muito tempo seja movido para uma fila de maior prioridade."
"O algoritmo de escalonamento 'Tarefa Mais Curta Primeiro' (SJF) é ótimo para sistemas interativos.";False;"Falso — O SJF não é prático para sistemas interativos por ser não-preemptivo e exigir conhecimento prévio do tempo de execução, o que é inviável."
"A chamada de sistema execve é usada para ler ou escrever em arquivos.";False;"Falso — A chamada execve substitui a imagem do processo atual por um novo programa."
"Um Pipe é um mecanismo de comunicação bidirecional entre processos.";False;"Falso — Pipes tradicionais no Unix são unidirecionais. Para comunicação bidirecional, são necessários dois pipes ou um socket."
"A estrutura básica de armazenamento de dados em meios persistentes, do ponto de vista do SO, é o arquivo.";True;"Verdadeiro — O arquivo é a abstração fundamental que o sistema operacional fornece para armazenar informações em discos e outros dispositivos."
"O registrador PC (Contador de Programa) armazena o resultado da última operação aritmética.";False;"Falso — O PC armazena o endereço de memória da próxima instrução a ser executada."
"Processos orientados a entrada e saída tendem a ter surtos curtos de uso de CPU.";True;"Verdadeiro — Processos I/O-bound usam a CPU por curtos períodos entre longas esperas por operações de E/S, como ler um disco ou aguardar dados da rede."
"Em um sistema monolítico, a visibilidade do código entre os módulos do kernel é irrestrita.";True;"Verdadeiro — Em um núcleo monolítico, todos os componentes rodam no mesmo espaço de endereçamento com alto acoplamento, podendo chamar funções uns dos outros livremente."
"O modelo de máquinas virtuais permite que um mesmo sistema operacional seja executado em vários computadores simultaneamente.";False;"Falso — Permite que vários sistemas operacionais sejam executados em um único computador físico simultaneamente."
"Threads de processos diferentes são mais independentes entre si do que threads do mesmo processo.";True;"Verdadeiro — Threads de processos diferentes são completamente isoladas em memória e recursos, enquanto threads do mesmo processo compartilham quase tudo."
"A principal contribuição das threads é permitir o paralelismo em chamadas bloqueantes.";True;"Verdadeiro — Threads permitem que uma parte do programa continue executando de forma produtiva enquanto outra parte está bloqueada esperando por uma operação de E/S."
"O escalonamento por chaveamento circular (Round-Robin) é um exemplo de algoritmo não-preemptivo.";False;"Falso — Round-Robin é preemptivo. Ele interrompe um processo à força quando seu quantum de tempo se esgota."
"Em um sistema de tempo real crítico, o descumprimento ocasional de um prazo é tolerável.";False;"Falso — Em sistemas de tempo real críticos (hard real-time), o descumprimento de um prazo é considerado uma falha catastrófica do sistema."
"O escalonamento por fração justa visa garantir que cada processo receba uma porção igual da CPU, independentemente de qual usuário o iniciou.";False;"Falso — O escalonamento por fração justa (fair share) visa dar uma porção da CPU para cada USUÁRIO, não para cada processo."
"A instrução TSL (Test-and-Set Lock) é uma solução de software para o problema da região crítica que não depende de suporte de hardware.";False;"Falso — TSL é uma instrução atômica de hardware, essencial para implementar soluções de sincronização eficientes."
"Em um sistema com threads em modo núcleo, o escalonador do SO escolhe qual processo executar, e a biblioteca de threads daquele processo escolhe qual de suas threads irá rodar.";False;"Falso — Com threads em modo núcleo, o escalonador do próprio SO tem conhecimento e escolhe qual THREAD específica executar."
"A principal desvantagem dos semáforos em relação aos monitores é a maior complexidade e a possibilidade de erros, como um impasse (deadlock).";True;"Verdadeiro — Semáforos são primitivas de baixo nível. É fácil cometer erros (ex: inverter a ordem de down/up), enquanto monitores são estruturas de alto nível que simplificam a sincronização."
"A técnica de RCU (Read-Copy-Update) é ideal para cenários com muitas operações de escrita e poucas de leitura.";False;"Falso — RCU é otimizado para cenários com muitas leituras e poucas escritas, pois permite que leitores acessem os dados sem bloqueios."
"A 'espera ocupada' (busy waiting) é eficiente em termos de uso da CPU, pois mantém o processador sempre ativo.";False;"Falso — É extremamente ineficiente, pois consome 100% da CPU em um laço de espera que não realiza trabalho útil."
"O principal objetivo da multiprogramação é permitir que múltiplos processos sejam executados em paralelo real em um único núcleo de CPU.";False;"Falso — O objetivo é maximizar a utilização da CPU através da concorrência, mantendo-a sempre ocupada com algum processo."
"Um processo pode transitar diretamente do estado 'Bloqueado' para o estado 'Em Execução' assim que o evento esperado ocorre.";False;"Falso — Quando o evento ocorre, o processo transita de 'Bloqueado' para 'Pronto'. Ele então aguarda o escalonador selecioná-lo para ir para 'Em Execução'."
"Em um servidor web multithread, a 'thread despachante' é geralmente responsável por processar a requisição do cliente.";False;"Falso — A thread despachante geralmente apenas recebe a requisição e a repassa para uma thread trabalhadora (worker) livre processá-la."
"A hierarquia de processos, comum em sistemas Unix, significa que todo processo, exceto o primeiro, foi criado por outro processo.";True;"Verdadeiro — Com exceção do processo inicial (init ou systemd), todo processo tem um processo pai, formando uma árvore hierárquica."
"A finalidade de uma barreira é garantir a exclusão mútua em uma região crítica.";False;"Falso — A finalidade de uma barreira é sincronizar múltiplas threads, fazendo com que todas esperem em um ponto específico antes de continuar."
"A troca de mensagens é um modelo de comunicação que se baseia no compartilhamento de memória entre processos.";False;"Falso — A troca de mensagens não requer memória compartilhada; o sistema operacional gerencia o envio e recebimento de dados entre os processos."
"Futexes são uma otimização que visa reduzir o número de chamadas de sistema em operações de mutex quando não há disputa pelo recurso.";True;"Verdadeiro — Futexes (fast userspace mutexes) evitam a sobrecarga de uma chamada de sistema se o recurso estiver livre, operando apenas no espaço do usuário."
"Na solução para o problema dos 'Leitores e Escritores', é sempre mais eficiente permitir que vários leitores e vários escritores acessem os dados simultaneamente.";False;"Falso — Permitir múltiplos escritores simultaneamente levaria a uma condição de corrida e corrupção de dados. Apenas múltiplos leitores são permitidos ao mesmo tempo."
"A solução de Peterson para o problema da região crítica funciona para qualquer número de processos.";False;"Falso — A solução original de Peterson funciona apenas para dois processos. Existem generalizações, mas a solução clássica é para N=2."
"Um 'erro fatal' é um tipo de término de processo voluntário, onde o próprio processo decide se encerrar.";False;"Falso — Um erro fatal (ex: divisão por zero) é um término involuntário, causado por uma condição de erro que o processo não pode tratar."
"O contador de programa (PC) é um item compartilhado entre todas as threads de um mesmo processo.";False;"Falso — O PC é único para cada thread, pois cada uma executa seu próprio fluxo de instruções e precisa saber onde parou."
"Um dos problemas de converter código monothread para multithread é que muitas rotinas de biblioteca não são reentrantes.";True;"Verdadeiro — Rotinas não reentrantes usam variáveis globais ou estáticas, o que pode causar condições de corrida quando chamadas por múltiplas threads simultaneamente."
"Em uma implementação de threads em modo usuário, o sistema operacional tem total conhecimento e controle sobre cada thread individualmente.";False;"Falso — O SO não tem conhecimento das threads em modo usuário; ele só gerencia o processo que as contém como uma única entidade."
"O escalonamento por prioridades pode levar ao problema de inanição (starvation), onde processos de baixa prioridade nunca são executados.";True;"Verdadeiro — Se sempre houver processos de alta prioridade prontos para executar, os de baixa prioridade podem ser indefinidamente adiados."
"O algoritmo de escalonamento 'Tempo Restante Mais Curto em Seguida' (SRTN) é um exemplo de escalonamento não-preemptivo.";False;"Falso — SRTN é a versão preemptiva do SJF. Se um novo processo chega com um tempo de execução menor que o tempo restante do processo atual, ele sofre preempção."
"A principal meta de um escalonador em sistemas em lote é minimizar o tempo de resposta para o usuário.";False;"Falso — A meta em sistemas em lote (batch) é maximizar a vazão (throughput) e a utilização da CPU, não a interatividade."
"O 'grau de multiprogramação' refere-se à quantidade de núcleos de CPU em um sistema.";False;"Falso — Refere-se à quantidade de processos que estão mantidos na memória principal, prontos para executar."
"A Tabela de Processos (PCB) armazena apenas os registradores e o contador de programa de um processo.";False;"Falso — O PCB é uma estrutura complexa que armazena muitas outras informações, como estado do processo, prioridade, limites de memória, arquivos abertos, etc."
"Um processo orientado à CPU tende a ter longos surtos de computação intercalados com curtas esperas por E/S.";True;"Verdadeiro — Processos CPU-bound realizam longos e intensos cálculos, sendo interrompidos apenas por breves períodos para E/S."
"O modelo de comunicação cliente-servidor só pode ser implementado em uma única máquina, sem o uso de rede.";False;"Falso — O modelo foi projetado para funcionar em redes, permitindo que o cliente e o servidor estejam em máquinas diferentes e se comuniquem pela rede."
"A principal função de uma controladora de dispositivo é executar o código dos aplicativos do usuário.";False;"Falso — A controladora é uma interface de hardware que o driver de dispositivo (código do SO) utiliza para gerenciar o dispositivo físico."
"Variáveis de condição são utilizadas para que uma thread possa esperar por uma condição específica sem precisar ficar em um laço de espera ocupada.";True;"Verdadeiro — Uma thread pode chamar 'wait' em uma variável de condição, sendo bloqueada de forma eficiente até que outra thread chame 'signal' ou 'broadcast'."
"A chamada pthread_yield força o término imediato da thread que a invocou.";False;"Falso — pthread_yield apenas sugere ao escalonador que outra thread poderia ser executada agora, cedendo voluntariamente a CPU, mas não termina a thread atual."
"O problema do 'Jantar dos Filósofos' é um exemplo clássico de um problema de impasse (deadlock).";True;"Verdadeiro — É um exemplo clássico onde a disputa circular por recursos (os garfos) pode levar a um impasse, com todos os filósofos esperando indefinidamente."
"A atomicidade das operações UP e DOWN em um semáforo é garantida pelo programador da aplicação, não pelo SO.";False;"Falso — A atomicidade é uma garantia fundamental fornecida pelo sistema operacional, geralmente através de instruções de hardware ou desabilitando interrupções."
"O RCU garante que um leitor sempre acessará a versão mais atualizada de um dado.";False;"Falso — Um leitor no RCU pode acessar uma versão ligeiramente desatualizada dos dados. A garantia é de consistência, não de atualidade imediata."
"O 'período de graça' no RCU é o tempo que um escritor deve esperar antes de começar a fazer a cópia da estrutura de dados.";False;"Falso — O período de graça é o tempo que o escritor espera, após a atualização, para que todos os leitores que estavam usando a versão antiga terminem."
"Aumentar a quantidade de memória em um sistema sempre melhora a utilização da CPU, sem limites.";False;"Falso — A utilização da CPU melhora até certo ponto. Com muitos processos na memória, o tempo gasto com a troca de contexto (overhead) pode se tornar um gargalo."
"O 'sistema supervisor' é um componente de software que gerencia threads em implementações no espaço do núcleo.";True;"Verdadeiro — O sistema supervisor (kernel) é responsável por criar, destruir e escalonar threads em modo núcleo, pois tem controle total sobre o hardware."
"Uma thread pode ler ou até mesmo apagar a pilha de outra thread que pertence ao mesmo processo.";True;"Verdadeiro — Como compartilham o mesmo espaço de endereçamento, uma thread maliciosa ou com bug pode acessar e corromper a pilha de outra, sendo uma fonte comum de erros."
"A chamada pthread_join é usada para criar uma nova thread.";False;"Falso — pthread_join faz com que uma thread espere pelo término de outra. Para criar uma nova thread, utiliza-se pthread_create."
"Nos monitores, a exclusão mútua é garantida implicitamente pela estrutura da linguagem, tornando o código menos propenso a erros.";True;"Verdadeiro — A estrutura do monitor garante que apenas uma thread possa estar ativa dentro de seus procedimentos por vez, simplificando a programação e evitando erros comuns."
"A alternância estrita (explicit alternation) é uma solução eficiente e flexível para o problema da região crítica.";False;"Falso — A alternância estrita é inflexível (viola o progresso se um processo for mais lento) e pode ser ineficiente."
"No problema do produtor-consumidor, um 'wakeup perdido' pode ocorrer se o consumidor for interrompido logo após verificar que o buffer está vazio, mas antes de dormir.";True;"Verdadeiro — É um problema clássico de sincronização. O produtor pode sinalizar o wakeup enquanto o consumidor está prestes a dormir, fazendo com que o sinal seja perdido."
"O uso da instrução TSL (Test-and-Set Lock) elimina a necessidade de um laço de repetição (espera ocupada).";False;"Falso — A instrução TSL é usada dentro de um laço de espera ocupada para garantir que a verificação e o bloqueio da variável de trava sejam atômicos."
"A principal vantagem de desabilitar interrupções para garantir exclusão mútua é que essa solução funciona perfeitamente em sistemas com múltiplos processadores.";False;"Falso — Desabilitar interrupções não funciona em sistemas multiprocessados, pois a instrução afeta apenas o núcleo onde foi executada, não os outros."
"A herança de prioridade é uma técnica onde uma tarefa de baixa prioridade herda a prioridade de uma tarefa de média prioridade que a está bloqueando.";False;"Falso — A herança de prioridade ocorre quando uma tarefa de baixa prioridade herda a prioridade da tarefa de ALTA prioridade que ela está bloqueando, para que possa liberar o recurso rapidamente."
"Um sistema de tempo real não-crítico (soft) pode tolerar o descumprimento ocasional de um prazo.";True;"Verdadeiro — Sistemas de tempo real 'soft' (ex: streaming de vídeo) visam cumprir os prazos, mas falhas ocasionais não são catastróficas e apenas degradam a qualidade."
"O algoritmo de escalonamento FCFS (Primeiro a Chegar, Primeiro a Ser Servido) pode causar o 'efeito comboio'.";True;"Verdadeiro — O 'efeito comboio' ocorre quando um processo longo chega primeiro e todos os processos curtos que chegam depois são forçados a esperar, mesmo sendo rápidos."
"O 'quantum' no escalonamento Round-Robin é o tempo total que um processo pode usar a CPU antes de terminar.";False;"Falso — O quantum é a fatia de tempo máxima que um processo pode usar a CPU antes de ser preemptado e devolvido para o final da fila de prontos."
"O objetivo de uma LibOS em um sistema Exokernel é fornecer acesso direto e desprotegido ao hardware.";False;"Falso — A LibOS (biblioteca de sistema operacional) em um Exokernel fornece as abstrações de alto nível (como arquivos), enquanto o kernel apenas multiplexa o hardware de forma segura."
"Unikernel combina a aplicação e as bibliotecas de SO necessárias em uma única imagem de máquina, visando máxima segurança e mínimo tamanho.";True;"Verdadeiro — Unikernels são imagens de máquina especializadas, contendo apenas o código da aplicação e as dependências do SO necessárias, ideais para ambientes de nuvem e virtualização."
"O conceito de 'Política versus Mecanismo' sugere que o sistema operacional deve sempre impor tanto as ferramentas de gerenciamento quanto a forma como elas são usadas.";False;"Falso — O ideal é que o SO forneça o 'mecanismo' (as ferramentas, ex: escalonador com prioridades) e o usuário defina a 'política' (como usar as ferramentas, ex: quais prioridades atribuir)."